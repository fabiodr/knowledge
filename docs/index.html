<!DOCTYPE html>
<html>

<head>
    <title>Knowledge Search</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <div id="searchbox">
        <div id="backsearch"></div>
        <div id="ask"></div>
        <div id="documents"></div>
    </div>
    <div class="graph" id="graph"></div>

    <script src="https://cdn.jsdelivr.net/npm/react@18.0.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.0.0/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/babel-standalone@6.26.0/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-spritetext@1.9.3/dist/three-spritetext.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-force-graph-3d@1.25.1/dist/react-force-graph-3d.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        const Search = () => {
            const [query, setQuery] = useState("");
            const [node, setNode] = useState(null);
            const [k, setK] = useState(40);
            const [isMobile, setIsMobile] = useState(window.innerWidth <= 768);

            // Refs for the separate search and plot timers
            const searchTimerRef = useRef(null);
            const plotTimerRef = useRef(null);

            const highlight = useCallback((text) => {
                if (!text) return "";
                let keywords = query;
                if (node) {
                    keywords += ` ${node}`;
                }
                const keywordSet = new Set(keywords.split(/\s+/).filter(token => token.length > 2));
                if (keywordSet.size === 0) return <div id="inline">{text}</div>;

                const parts = text.split(new RegExp(`(${Array.from(keywordSet).join("|")})`, 'gi'));
                return (
                    <div id="inline">
                        {parts.map((part, i) =>
                            keywordSet.has(part.toLowerCase()) ? <div id="highlight" key={i}>{part}</div> : part
                        )}
                    </div>
                );
            }, [query, node]);

            const renderDocuments = useCallback((documents) => {
                ReactDOM.render(
                    <div>
                        {(documents || []).map((doc, index) => (
                            <div id="document" key={doc.url || index}>
                                <a className="title" href={doc.url} target="_blank" rel="noopener noreferrer">{highlight(doc.title)}</a>
                                <div id="date" onClick={() => handleClickDate()}>{highlight(doc.date)}</div>
                                <div id="summary">{highlight(doc.summary)}</div>
                                <div id="tags">
                                    {(doc.tags || []).concat(doc["extra-tags"] || []).map((tag, i) => (
                                        <div id="tag" key={i} onClick={() => handleClickTag(tag)}>
                                            {highlight(tag)}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>,
                    document.getElementById('documents')
                );
            }, [highlight]);

            const fetchLatest = useCallback(() => {
                const graphContainer = document.getElementById('graph');
                if (graphContainer) {
                    ReactDOM.unmountComponentAtNode(graphContainer);
                }
                fetch(`http://127.0.0.1:8000/latest/30`)
                    .then(res => res.json())
                    .then(data => renderDocuments(data.documents))
                    .catch(error => console.error("Failed to fetch latest documents:", error));
            }, [renderDocuments]);

            const search = useCallback((searchQuery, searchK, sort = true) => {
                if (!searchQuery.trim()) {
                    fetchLatest();
                    return;
                }

                fetch(`http://127.0.0.1:8000/search/${sort}/${node}/${searchK}/${searchQuery.replace("/", "")}`)
                    .then(res => res.json())
                    .then(data => {
                        renderDocuments(Object.values(data["documents"]));
                    })
                    .catch(error => console.error("Failed to fetch search results:", error));
            }, [node, fetchLatest, renderDocuments]);

            const handleHoverNode = useCallback((hoveredNode) => {
                if (hoveredNode) {
                    setNode(hoveredNode.id);
                    search(`${query} ${hoveredNode.id}`, k);
                    window.history.pushState({}, null, `?query=${encodeURIComponent(query)}&node=${encodeURIComponent(hoveredNode.id)}`);
                }
            }, [query, search, k]);

            const plot = useCallback((plotQuery, plotK) => {
                if (isMobile || !plotQuery.trim()) {
                    const graphContainer = document.getElementById('graph');
                    if (graphContainer && graphContainer.hasChildNodes()) {
                        ReactDOM.unmountComponentAtNode(graphContainer);
                    }
                    return;
                }

                fetch(`http://127.0.0.1:8000/plot/${plotK}/${plotQuery.replace("/", "")}`)
                    .then(res => res.json())
                    .then(data => {
                        ReactDOM.render(
                            <ForceGraph3D
                                graphData={data}
                                backgroundColor="#131317"
                                width={window.innerWidth / 2}
                                height={window.innerHeight}
                                showNavInfo={false}
                                nodeAutoColorBy="group"
                                linkOpacity={0.6}
                                linkWidth={0.1}
                                nodeThreeObject={node => {
                                    const sprite = new SpriteText(node.id);
                                    sprite.color = node.color;
                                    sprite.textHeight = 4;
                                    sprite.fontSize = 50;
                                    sprite.fontFace = "Futura";
                                    return sprite;
                                }}
                                onNodeHover={handleHoverNode}
                            />,
                            document.getElementById('graph')
                        );
                    }).catch(error => console.error("Failed to plot graph:", error));
            }, [isMobile, handleHoverNode]);

            // This function runs the search and plot immediately.
            // Used for clicks and initial page load.
            const runNow = useCallback((runQuery, runK) => {
                clearTimeout(searchTimerRef.current);
                clearTimeout(plotTimerRef.current);
                search(runQuery, runK, false);
                plot(runQuery, runK);
            }, [search, plot]);

            useEffect(() => {
                const handleResize = () => setIsMobile(window.innerWidth <= 768);
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            useEffect(() => {
                const params = new URLSearchParams(window.location.search);
                const urlQuery = params.get("query") || "";
                const urlNode = params.get("node") || null;

                if (urlQuery) {
                    setQuery(urlQuery);
                    runNow(urlQuery, k); // Run immediately on initial load
                    if (urlNode) {
                        setNode(urlNode);
                        search(`${urlQuery} ${urlNode}`, k);
                    }
                } else {
                    fetchLatest();
                }
            }, []); // Run only once on component mount

            const handleChangeText = (event) => {
                const newQuery = event.target.value.toLowerCase();
                setQuery(newQuery);
                setNode(null);
                window.history.pushState({}, null, `?query=${encodeURIComponent(newQuery)}`);

                // Clear previous timers
                clearTimeout(searchTimerRef.current);
                clearTimeout(plotTimerRef.current);

                // Set new timers with different delays
                searchTimerRef.current = setTimeout(() => {
                    search(newQuery, k);
                }, 200); // 200ms delay for search bar results

                plotTimerRef.current = setTimeout(() => {
                    plot(newQuery, k);
                }, 500); // 500ms delay for the plot
            };

            const handleClickDate = () => {
                search(query, k, false); // Run search without sorting
            };

            const handleClickTag = (tag) => {
                const newQuery = `${query} ${tag}`.trim();
                setQuery(newQuery);
                document.getElementById("search").value = newQuery;
                window.history.pushState({}, null, `?query=${encodeURIComponent(newQuery)}`);
                runNow(newQuery, k, false); // Run immediately on tag click
            };

            return (
                <React.Fragment>
                    <input id="search" type="textarea" placeholder="Neural Search" value={query} onChange={handleChangeText} autoFocus />
                </React.Fragment>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('backsearch'));
        root.render(<Search />);
    </script>
</body>

</html>